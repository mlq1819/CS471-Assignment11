Michael Quinn

1a. Use interactive Haskell
	Got it?

1b. Commands
	Yup
	
1c. There's a book
	nice

2f)
	factorial 5 returns 120, which is indeed the factorial of 5. The inferred type of "factorial" is "(Eq p, Num p) => p -> p", which seems to mean it takes an object p which is both a Num and of class "Eq", and returns another object p which is of the same classes.
	
3) write some code; I wrote some code

4) Run experiments; what happens and why?
	All three return the same values for inputs of 12 and 13, but fact1 returns 0 instead of what is presumably the correct answer (which factorial and fact2 both return). I believe that factorial and fact2 both end up using a larger type than fact1, which uses Int, and due to the differences between these two, Integer ends up used by factorial and fact2. If this is the case, Integer is a more stable/better version of Int. If it is similar to the language Idris that I worked on for a presentation, it is then because Integer can theoretically hold a value of any size, while Int is limited to a maximum value, which could easily be reached through this means.

5. More experiments: factorial (-2) and factorial -2
The first one causes a stack overflow from recursive function calls. The second causes a syntax error, as "-2" is technically of a different type than (-2), since it inspects the "-" separately in that context from the "2".

6. More edits, write a thing and test it
	K, wrote it and tested it

7. More edits, use guards; how many basic types can factG accept? What happens on factG (-2)?
	Assuming "accept" means that it can run using a value of that data type without producing an error, factG can accept two basic types: namely, Int and Integer. This is because it only allows values that can be compared, which Float should be part of, but by the definition of the function and through recursion, it will always eventually recurse using a negative number if provided a float.
	Speaking of which, running factG on (-2) produces the user-defined error of "Exception: neg x".
	
8. More edits, add factI and factE. Type some expressions; what happens and why? Type some more; what happens, and guess why it does?
	For the first set of prompts, all three prompts produce errors. Calling factorial on a Float causes a stack overflow, as its definition technically uses no functions or operators that don't work on Floats, and doesn't exclude them, though the function definition itself will only ever end when the provided value is decremented to 0 through units of 1, which can never happen when the provided value is a float. The second prompt causes a user-provided exception for neg x, for the same reason as both the previous question and previous prompt: it recurses into a negative value, which isn't accepted by the function definition. The third error is the first error that happens before the function is called; it instead only accepts Integers, and passing it a Float causes a "No instance" error for fractional integers.
	The second 
	